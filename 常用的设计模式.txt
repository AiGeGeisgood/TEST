模板方法：聚合功能方法在父类
策略模式：（接口实现if-else内容）通过接口延迟实现功能，（其实就是指针）
观察者模式：（事件订阅、监听；用到委托回调）
装饰器模式（不改变接口，增加功能）（通过组合减少类数量）
桥模式（通过组合减少类数量）：将两个不同职责的接口分离，并组合
工厂模式：通过接口延迟创建对象
抽象工厂：多工厂集合
原型模式：指针克隆
构造器模式：（链式调用？）
单例模式：
享元模式：增加复用对象
外观模式（封装功能，简化调用）
代理模式：（相同接口增加中间层劫持，改变调用）
适配器模式：（改变接口后适配，最好使用对象适配器）
中介者模式：（中介集中处理回调事件）
状态模式：（消除if-esle三角形地狱）：通过接口延迟实现功能，并传递到下一个状态
备忘录：已被序列化功能淘汰
组合模式：（通过树形结构，进行功能组合）
迭代器模式：在C++中，被模板元编程中替代，其他C#，java依然使用
职责链模式：通过链表传递功能
命令模式：通过函数对象替代
访问器模式：适用于函数功能不断增加变换，但是类极其稳定的项目
解析器模式：集成一个解析器，用来特殊处理一个功能流程


——设计模式的目标
隔离变化与稳定，提高复用，抵御变化。
增加稳定中间层接口，隔离低层模块（实现细节）对高层模块的依赖。

依赖倒置：
高层模块（稳定）不应该依赖于低层模块（变化），二者都应该依赖于抽象（稳定）。
抽象（稳定）不应该依赖于实现细节（变化），实现细节（变化）应该依赖于抽象（稳定）。

开闭原则：
对扩展发放，对更改封闭。
类模块应该是可扩展的，但是不可修改。

单一职责：
一个类应该仅有一个引起它变化的原因。
变化的方向隐含着类的责任。

Liskov替换原则：
子类必须能够替换它们的基类(IS-A)。
继承表达类型抽象。

接口隔离：
不应该强迫客户端依赖它们不用的方法。
接口应该小而完备。

对象组合优于继承，优先使用组合：
类继承通常为“白箱复用" ，对象组合通常为“黑箱复用”。
继承在某种程度上破坏了封装性，子类父类耦合度高。
而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低

封装变化点：
一侧变化一侧稳定


继承->组合
编译时依赖->运行时依赖
即时->延迟
静态绑定->动态绑定
紧耦合->松耦合